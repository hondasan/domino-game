<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Domino Critical</title>
    <!-- 物理演算ライブラリ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #050505;
            color: white;
            font-family: 'Verdana', sans-serif;
            overflow: hidden;
            touch-action: none;
            height: 100vh;
            width: 100vw;
            user-select: none;
            -webkit-user-select: none;
            position: relative;
        }

        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 10;
        }

        .header {
            padding: 20px;
            text-align: center;
            background: linear-gradient(to bottom, rgba(0,0,0,0.8), transparent);
            position: relative;
            height: 100px;
        }

        #force-finish-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            pointer-events: auto;
            background: rgba(255, 0, 85, 0.4);
            border: 2px solid rgba(255, 0, 85, 1);
            color: #fff;
            font-size: 14px;
            font-weight: bold;
            padding: 10px 15px;
            border-radius: 8px;
            cursor: pointer;
            text-transform: uppercase;
            z-index: 9999;
            box-shadow: 0 0 10px rgba(255,0,85,0.5);
            display: none; 
        }
        #force-finish-btn:active { background: rgba(255, 0, 85, 0.8); transform: scale(0.95); }

        .score-box {
            font-size: 48px;
            font-weight: 900;
            color: #00ffcc;
            text-shadow: 0 0 15px rgba(0, 255, 204, 0.8);
            letter-spacing: 1px;
            font-variant-numeric: tabular-nums;
        }

        .sub-info {
            font-size: 12px;
            color: #888;
            margin-top: 5px;
            text-transform: uppercase;
        }

        #message-area {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            pointer-events: auto;
            width: 90%;
            max-width: 400px;
            background: rgba(10, 10, 10, 0.9);
            padding: 30px 20px;
            border-radius: 20px;
            border: 1px solid #444;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }

        .btn-start {
            font-size: 28px;
            font-weight: bold;
            color: #000;
            background: #00ffcc;
            padding: 15px 40px;
            border-radius: 50px;
            border: none;
            box-shadow: 0 0 20px #00ffcc;
            cursor: pointer;
            animation: pulse 1.5s infinite;
            text-transform: uppercase;
            white-space: nowrap;
        }

        .jackpot-text {
            position: absolute;
            font-weight: 900;
            pointer-events: none;
            text-shadow: 0 0 10px #000;
            white-space: nowrap;
            z-index: 100;
            animation: floatUp 1.0s ease-out forwards;
        }

        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(0, 255, 204, 0.7); }
            70% { transform: scale(1.05); box-shadow: 0 0 0 20px rgba(0, 255, 204, 0); }
            100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(0, 255, 204, 0); }
        }
        
        @keyframes floatUp {
            0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
            10% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
            100% { transform: translate(-50%, -150%) scale(1.0); opacity: 0; }
        }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="header">
            <div id="score" class="score-box">0</div>
            <div class="sub-info">
                Best: <span id="high-score">0</span><br>
                Balls: <span id="ball-count">0</span>
            </div>
            <button id="force-finish-btn">FINISH</button>
        </div>
        <div id="message-area">
            <button id="start-btn" class="btn-start">TAP TO START</button>
            <div style="margin-top:15px; font-size:11px; color:#888;">
                High Score Auto-Save Enabled
            </div>
        </div>
    </div>

<script>
    // --- 設定 ---
    const CONFIG = {
        superJackpotChance: 0.001, 
        miniJackpotChance: 0.01,   
        x100Chance: 0.005,         
        splitChance: 0.20,         
        
        ballSize: 4.5,
        pegSize: 4.0, // 少し大きくして当たりやすく
        gravity: 1.1,
        bounciness: 0.8, // 永遠に跳ねるのを防ぐため少し下げる
        baseScore: 100,
        x100Multiplier: 100 
    };

    const PALETTE = [
        { color: '#00ffff', note: 0,  type: 'sine' },     
        { color: '#00ffaa', note: 2,  type: 'sine' },     
        { color: '#ffff00', note: 4,  type: 'triangle' }, 
        { color: '#ffaa00', note: 7,  type: 'sine' },     
        { color: '#ff0055', note: 9,  type: 'triangle' }, 
        { color: '#aa00ff', note: 12, type: 'sine' },     
        { color: '#ffffff', note: 14, type: 'square' }    
    ];

    let engine, render, runner, world;
    let score = 0;
    let highScore = parseInt(localStorage.getItem('domino_critical_highscore_v11')) || 0;
    
    let isPlaying = false;
    let hasStarted = false; 
    let ballCount = 0;
    let audioCtx = null;

    const scoreEl = document.getElementById('score');
    const highScoreEl = document.getElementById('high-score');
    const ballCountEl = document.getElementById('ball-count');
    const startBtn = document.getElementById('start-btn');
    const msgArea = document.getElementById('message-area');
    const finishBtn = document.getElementById('force-finish-btn');

    highScoreEl.textContent = highScore.toLocaleString();

    const { Engine, Render, Runner, Bodies, Composite, Events, Body } = Matter;

    // --- Sound ---
    const Sound = {
        init: () => {
            if (!audioCtx) {
                const AC = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AC();
            }
            if (audioCtx.state === 'suspended') audioCtx.resume();
        },
        playTone: (noteIndex, waveType, isHighValue) => {
            if (!audioCtx) return;
            if (!isHighValue) {
                if (ballCount > 100 && Math.random() < 0.7) return; 
            }
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            const baseFreq = isHighValue ? 220 : 523.25;
            const freq = baseFreq * Math.pow(2, noteIndex / 12);
            osc.type = waveType || 'sine';
            osc.frequency.setValueAtTime(freq, t);
            const duration = isHighValue ? 0.3 : 0.1;
            gain.gain.setValueAtTime(isHighValue ? 0.3 : 0.05, t);
            gain.gain.exponentialRampToValueAtTime(0.001, t + duration);
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            osc.start();
            osc.stop(t + duration + 0.05);
        },
        playJackpot: (type) => {
            if (!audioCtx) return;
            const t = audioCtx.currentTime;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            
            osc.connect(g);
            g.connect(audioCtx.destination);
            
            if(type === 'super') {
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(100, t);
                osc.frequency.exponentialRampToValueAtTime(5000, t + 1.0);
                g.gain.setValueAtTime(0.3, t);
                g.gain.exponentialRampToValueAtTime(0.001, t + 1.0);
                osc.start(t);
                osc.stop(t+1.0);
            } else if (type === 'x100') {
                osc.type = 'square';
                osc.frequency.setValueAtTime(50, t);
                osc.frequency.linearRampToValueAtTime(100, t + 0.1);
                g.gain.setValueAtTime(0.5, t);
                g.gain.exponentialRampToValueAtTime(0.001, t + 0.5);
                osc.start(t);
                osc.stop(t+0.5);
            } else {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(880, t);
                osc.frequency.linearRampToValueAtTime(1760, t + 0.2);
                g.gain.setValueAtTime(0.1, t);
                g.gain.linearRampToValueAtTime(0, t + 0.2);
                osc.start(t);
                osc.stop(t+0.2);
            }
        }
    };

    function init() {
        engine = Engine.create();
        world = engine.world;
        engine.gravity.y = CONFIG.gravity;

        render = Render.create({
            element: document.body,
            engine: engine,
            options: {
                width: window.innerWidth,
                height: window.innerHeight,
                wireframes: false,
                background: '#050505',
                pixelRatio: 1 
            }
        });
        render.canvas.id = "game-canvas";
        
        // ステージ初期生成（見栄え用）
        createStage();

        Events.on(engine, 'collisionStart', handleCollision);
        Events.on(engine, 'beforeUpdate', handleGameLoop);

        Render.run(render);
        runner = Runner.create();
        Runner.run(runner, engine);

        window.addEventListener('resize', () => {
            render.canvas.width = window.innerWidth;
            render.canvas.height = window.innerHeight;
            // リサイズ時はプレイ中でなければ再生成してあげる
            if(!isPlaying) {
                createStage();
            }
        });

        startBtn.addEventListener('click', startGame);
        finishBtn.addEventListener('click', () => { 
            if(isPlaying) endGame(); 
        });
    }

    // ステージ（ピンと壁）を一括生成する関数
    function createStage() {
        // 既存のピンと壁を削除
        const bodies = Composite.allBodies(world);
        const stageBodies = bodies.filter(b => b.label === 'peg' || b.label === 'wall');
        Composite.remove(world, stageBodies);

        createPegs();
        createWalls();
    }

    function createPegs() {
        const width = window.innerWidth;
        const height = window.innerHeight;
        // 幅が極端に狭い場合の安全策
        if (width < 100) return;

        const cols = Math.floor(width / 30); 
        const rows = Math.floor(height / 45);
        const startY = 130; 
        
        for (let r = 0; r < rows - 1; r++) {
            for (let c = 0; c < cols + 1; c++) {
                const offset = (r % 2 === 0) ? 0 : 15;
                const x = (c * 30) + offset;
                const y = startY + (r * 45);
                
                if (x > 20 && x < width - 20) {
                    const peg = Bodies.circle(x, y, CONFIG.pegSize, {
                        isStatic: true, 
                        label: 'peg', 
                        restitution: 0.8, 
                        render: { 
                            fillStyle: '#004444', // 暗い青緑（常時見えるように）
                            strokeStyle: '#00ffcc', // ネオンカラーの枠線
                            lineWidth: 2
                        }
                    });
                    Composite.add(world, peg);
                }
            }
        }
    }

    function createWalls() {
        const w = window.innerWidth;
        const h = window.innerHeight;
        // 壁（見えないけどある）
        const opts = { isStatic: true, label: 'wall', render: { visible: false } }; 
        Composite.add(world, [
            Bodies.rectangle(0, h/2, 20, h, opts),
            Bodies.rectangle(w, h/2, 20, h, opts)
        ]);
    }

    function startGame() {
        if (isPlaying) return;
        Sound.init();
        
        cleanupBalls();
        
        // 重要：スタート時に必ずステージを再構築する（サイズズレ防止）
        createStage();
        
        score = 0;
        ballCount = 0;
        hasStarted = false;
        isPlaying = true;
        
        updateUI();
        
        msgArea.classList.add('hidden');
        finishBtn.style.display = 'block'; 
        
        spawnBall(window.innerWidth / 2, 40, 'master');
        hasStarted = true;
    }

    function cleanupBalls() {
        const bodies = Composite.allBodies(world);
        const balls = bodies.filter(b => b.label === 'ball');
        if(balls.length > 0) {
            Composite.remove(world, balls);
        }
    }

    function spawnBall(x, y, type = 'normal') {
        if (!isPlaying) return;

        let style;
        let isX100 = false;
        
        if (type === 'master') {
            style = { color: '#ffffff', note: 12, type: 'square' };
        } else if (type === 'super') {
            style = { color: '#ffffff', note: 14, type: 'sawtooth' }; 
        } else if (type === 'mini') {
            style = { color: '#ffcc00', note: 9, type: 'square' }; 
        } else if (type === 'x100') {
            style = { color: '#ff0000', note: -5, type: 'sawtooth' };
            isX100 = true;
        } else {
            style = PALETTE[Math.floor(Math.random() * PALETTE.length)];
        }

        const ball = Bodies.circle(x, y, CONFIG.ballSize, {
            restitution: CONFIG.bounciness,
            friction: 0.000,
            frictionAir: 0.005,
            label: 'ball',
            render: { 
                fillStyle: style.color,
                strokeStyle: isX100 ? '#ffff00' : 'transparent',
                lineWidth: isX100 ? 2 : 0
            },
            plugin: { 
                note: style.note, wave: style.type, isX100: isX100
            }
        });

        Body.setVelocity(ball, { 
            x: (Math.random() - 0.5) * 8, y: (Math.random() - 0.5) * 8 
        });

        Composite.add(world, ball);
    }

    function showFloatingText(text, x, y, type) {
        if(!isPlaying) return;
        const div = document.createElement('div');
        div.className = 'jackpot-text';
        div.innerText = text;
        div.style.left = x + 'px';
        div.style.top = y + 'px';
        
        if(type === 'super') {
            div.style.fontSize = '36px'; div.style.color = '#fff'; div.style.textShadow = '0 0 20px gold';
        } else if (type === 'x100') {
            div.style.fontSize = '28px'; div.style.color = '#ff0000'; div.style.textShadow = '0 0 10px yellow';
        } else if (type === 'mini') {
            div.style.fontSize = '24px'; div.style.color = '#ffcc00';
        } else {
            div.style.fontSize = '16px'; div.style.color = '#fff';
        }
        document.body.appendChild(div);
        setTimeout(() => div.remove(), 1000);
    }

    function handleCollision(event) {
        if (!isPlaying) return;
        event.pairs.forEach(pair => {
            const bodyA = pair.bodyA;
            const bodyB = pair.bodyB;

            if ((bodyA.label === 'ball' && bodyB.label === 'peg') || 
                (bodyB.label === 'ball' && bodyA.label === 'peg')) {
                
                const ball = bodyA.label === 'ball' ? bodyA : bodyB;
                const peg = bodyA.label === 'peg' ? bodyA : bodyB;

                let hitScore = CONFIG.baseScore;
                if (ball.plugin && ball.plugin.isX100) {
                    hitScore = CONFIG.baseScore * CONFIG.x100Multiplier;
                    Sound.playTone(ball.plugin.note, 'sawtooth', true);
                } else {
                    if(ball.plugin) Sound.playTone(ball.plugin.note, ball.plugin.wave, false);
                }
                score += hitScore;

                if (Math.random() > 0.6) {
                    // ピンを一時的に明るくする
                    peg.render.fillStyle = ball.render.fillStyle;
                    peg.render.strokeStyle = '#fff';
                    setTimeout(() => { 
                        peg.render.fillStyle = '#004444'; 
                        peg.render.strokeStyle = '#00ffcc';
                    }, 100);
                }

                const rand = Math.random();
                const spawnType = (ball.plugin && ball.plugin.isX100) ? 'x100' : 'normal';

                if (rand < CONFIG.superJackpotChance) {
                    Sound.playJackpot('super');
                    score += 100000;
                    showFloatingText("SUPER JACKPOT!!!", window.innerWidth/2, window.innerHeight/3, 'super');
                    let created = 0;
                    const burst = () => {
                        if (!isPlaying) return; 
                        for(let k=0; k<5; k++) { 
                            if(created >= 100) return;
                            spawnBall(ball.position.x, ball.position.y, spawnType === 'x100' ? 'x100' : 'super');
                            created++;
                        }
                        if(created < 100) requestAnimationFrame(burst);
                    };
                    burst();
                } 
                else if (rand < CONFIG.superJackpotChance + CONFIG.x100Chance) {
                    Sound.playJackpot('x100');
                    showFloatingText("x100 BALL!!", ball.position.x, ball.position.y, 'x100');
                    spawnBall(ball.position.x, ball.position.y, 'x100');
                }
                else if (rand < CONFIG.superJackpotChance + CONFIG.x100Chance + CONFIG.miniJackpotChance) {
                    Sound.playJackpot('mini');
                    score += 5000;
                    showFloatingText("LUCKY 10!", ball.position.x, ball.position.y, 'mini');
                    for(let i=0; i<10; i++) {
                        spawnBall(ball.position.x, ball.position.y, spawnType === 'x100' ? 'x100' : 'mini');
                    }
                }
                else if (rand < CONFIG.superJackpotChance + CONFIG.x100Chance + CONFIG.miniJackpotChance + CONFIG.splitChance) {
                    score += 500;
                    spawnBall(ball.position.x, ball.position.y, spawnType);
                }
            }
        });
    }

    function handleGameLoop() {
        if (!isPlaying) return;

        const bodies = Composite.allBodies(world);
        const h = window.innerHeight;
        let currentBallCount = 0;
        
        for (let i = 0; i < bodies.length; i++) {
            const b = bodies[i];
            if (b.label === 'ball') {
                if(b.position.y > h + 10) {
                    Composite.remove(world, b);
                } else {
                    currentBallCount++;
                }
            }
        }
        
        ballCount = currentBallCount;

        if (hasStarted && ballCount === 0) {
            endGame();
        }
        
        if (engine.timing.timestamp % 200 < 20) updateUI();
    }

    function endGame() {
        if (!isPlaying) return;
        isPlaying = false; 
        
        finishBtn.style.display = 'none'; 

        if (score > highScore) {
            highScore = score;
            localStorage.setItem('domino_critical_highscore_v11', highScore);
            highScoreEl.textContent = Number(highScore).toLocaleString();
        }

        startBtn.textContent = "RETRY";
        
        msgArea.innerHTML = '';
        msgArea.appendChild(startBtn);
        
        const resDiv = document.createElement('div');
        resDiv.innerHTML = `
            <div style="margin-top:20px; font-size:14px; color:#aaa;">RESULT</div>
            <div style="font-size:36px; color:#fff; font-weight:bold; text-shadow:0 0 10px #00ffcc;">${score.toLocaleString()}</div>
        `;
        msgArea.appendChild(resDiv);

        msgArea.classList.remove('hidden');
        updateUI();
    }

    function updateUI() {
        scoreEl.textContent = score.toLocaleString();
        ballCountEl.textContent = ballCount;
    }

    window.onload = init;

</script>
</body>
</html>